// LALRPOP grammar for PureScript
// Fast, production-grade parser with full span tracking

use crate::cst::*;
use crate::lexer::Token;
use crate::ast::span::Span;
use crate::lexer::token::Ident;

grammar;

// ===== Module Structure =====

pub Module: Module = {
    <start:@L> "module" <name:ModuleName> <exports:ExportList?> "where"
    "{" <items:ImportOrDeclList> "}"
    <end:@R> => {
        let mut imports = vec![];
        let mut decls = vec![];
        for item in items {
            match item {
                ImportOrDecl::Import(i) => imports.push(i),
                ImportOrDecl::Decl(d) => decls.push(d),
            }
        }
        Module {
            span: Span::new(start, end),
            name,
            exports,
            imports,
            decls,
        }
    }
};

// Custom declaration list that handles instance chains (connected by `else` without `;`)
ImportOrDeclList: Vec<ImportOrDecl> = {
    <all:(<ImportOrDeclItem> ";")*> <last:ImportOrDeclItem?> => {
        let mut result = Vec::new();
        for item in all { result.extend(item); }
        if let Some(last) = last { result.extend(last); }
        result
    },
};

ImportOrDeclItem: Vec<ImportOrDecl> = {
    <i:ImportDecl> => vec![ImportOrDecl::Import(i)],
    <d:Decl> => vec![ImportOrDecl::Decl(d)],
    // Instance chain: instance ... else instance ... (else connects without ;)
    <first:InstanceDecl> <rest:("else" <InstanceDecl>)*> => {
        let mut v = vec![ImportOrDecl::Decl(first)];
        for inst in rest { v.push(ImportOrDecl::Decl(inst)); }
        v
    },
    // Leading else instance chain: else instance ... else instance ...
    "else" <first:InstanceDecl> <rest:("else" <InstanceDecl>)*> => {
        let mut v = vec![ImportOrDecl::Decl(first)];
        for inst in rest { v.push(ImportOrDecl::Decl(inst)); }
        v
    },
};

ModuleName: Spanned<ModuleName> = {
    <start:@L> <name:UpperIdent> <end:@R> => {
        Spanned::new(
            ModuleName { parts: vec![name] },
            Span::new(start, end)
        )
    },
    <start:@L> <qual:QualifiedUpper> <end:@R> => {
        // QualifiedUpper(module_sym, name_sym): module_sym is "A.B", name is "C"
        // Split module_sym back into parts
        let module_str = crate::interner::resolve(qual.0).unwrap_or_default();
        let mut parts: Vec<Ident> = module_str.split('.')
            .map(|s| crate::interner::intern(s))
            .collect();
        parts.push(qual.1);
        Spanned::new(
            ModuleName { parts },
            Span::new(start, end)
        )
    },
};

// ===== Exports =====

ExportList: Spanned<ExportList> = {
    <start:@L> "(" <exports:Sep<Export, ",">> ")" <end:@R> => {
        Spanned::new(
            ExportList { exports },
            Span::new(start, end)
        )
    }
};

Export: Export = {
    <name:LowerIdent> => Export::Value(name),
    <name:UpperIdent> <members:DataMembersOpt> => Export::Type(name, members),
    "class" <name:UpperIdent> => Export::Class(name),
    "module" <name:ModuleName> => Export::Module(name.value),
    "type" "(" <op:Operator> ")" => Export::TypeOp(op),
    "(" <op:Operator> ")" => Export::Value(op),
    "(" ":" ")" => Export::Value(crate::interner::intern(":")),
    "(" "~" ")" => Export::Value(crate::interner::intern("~")),
    "type" "(" ":" ")" => Export::TypeOp(crate::interner::intern(":")),
    "type" "(" "~" ")" => Export::TypeOp(crate::interner::intern("~")),
    "as" => Export::Value(crate::interner::intern("as")),
};

DataMembersOpt: Option<DataMembers> = {
    => None,
    "(" DotDot ")" => Some(DataMembers::All),
    "(" <members:Sep<UpperIdent, ",">> ")" => Some(DataMembers::Explicit(members)),
};

DotDot: () = {
    Operator =>? {
        if crate::interner::resolve(<>).as_deref() == Some("..") {
            Ok(())
        } else {
            Err(lalrpop_util::ParseError::User { error: format!("expected ..") })
        }
    },
};

// Negation operator prefix: matches only the `-` operator
NegateOp: () = {
    Operator =>? {
        if crate::interner::resolve(<>).as_deref() == Some("-") {
            Ok(())
        } else {
            Err(lalrpop_util::ParseError::User { error: format!("expected -") })
        }
    },
};

// ===== Imports =====

ImportDecl: ImportDecl = {
    <start:@L> "import" <module:ModuleName>
    <imports:ImportItems?>
    <qualified:("as" <ModuleName>)?> <end:@R> => {
        ImportDecl {
            span: Span::new(start, end),
            module: module.value,
            imports,
            qualified: qualified.map(|m| m.value),
        }
    }
};

ImportItems: ImportList = {
    "(" <items:Sep<Import, ",">> ")" => ImportList::Explicit(items),
    "hiding" "(" <items:Sep<Import, ",">> ")" => ImportList::Hiding(items),
};

Import: Import = {
    <name:LowerIdent> => Import::Value(name),
    <name:UpperIdent> <members:DataMembersOpt> => Import::Type(name, members),
    "class" <name:UpperIdent> => Import::Class(name),
    "type" "(" <op:Operator> ")" => Import::TypeOp(op),
    "(" <op:Operator> ")" => Import::Value(op),
    "(" ":" ")" => Import::Value(crate::interner::intern(":")),
    "(" "~" ")" => Import::Value(crate::interner::intern("~")),
    "type" "(" ":" ")" => Import::TypeOp(crate::interner::intern(":")),
    "type" "(" "~" ")" => Import::TypeOp(crate::interner::intern("~")),
    "as" => Import::Value(crate::interner::intern("as")),
};

// ===== Declarations =====

Decl: Decl = {
    TypeSignature,
    ValueDecl,
    DataDecl,
    TypeAliasDecl,
    NewtypeDecl,
    ClassDecl,
    DeriveDecl,
    ForeignDecl,
    FixityDecl,
};

TypeSignature: Decl = {
    <start:@L> <name:LowerIdentSpanned> "::" <ty:TypeExpr> <end:@R> => {
        Decl::TypeSignature {
            span: Span::new(start, end),
            name,
            ty,
        }
    }
};

ValueDecl: Decl = {
    // Unguarded: name binders = expr where?
    <start:@L> <name:LowerIdentSpanned> <binders:AtomicBinder*> "=" <expr:Expr>
    <wc:WhereClause?> <end:@R> => {
        Decl::Value {
            span: Span::new(start, end),
            name,
            binders,
            guarded: GuardedExpr::Unconditional(Box::new(expr)),
            where_clause: wc.unwrap_or_default(),
        }
    },
    // Guarded: name binders | guard = expr ...
    // Per-guard where clauses are handled inside each Guard; no declaration-level where for guarded decls.
    <start:@L> <name:LowerIdentSpanned> <binders:AtomicBinder*> <guards:Guard+> <end:@R> => {
        Decl::Value {
            span: Span::new(start, end),
            name,
            binders,
            guarded: GuardedExpr::Guarded(guards),
            where_clause: vec![],
        }
    },
};

WhereClause: Vec<LetBinding> = {
    "where" "{" <bindings:Sep<LetBinding, ";">> "}" => bindings,
};

Guard: Guard = {
    <start:@L> "|" <first:GuardItem> <rest:("," <GuardItem>)*> "=" <expr:Expr> <wc:WhereClause?> <end:@R> => {
        let mut patterns = vec![first];
        patterns.extend(rest);
        // Per-guard where clause: wrap expression in Let
        let final_expr = if let Some(bindings) = wc {
            Expr::Let {
                span: Span::new(start, end),
                bindings,
                body: Box::new(expr),
            }
        } else {
            expr
        };
        Guard {
            span: Span::new(start, end),
            patterns,
            expr: Box::new(final_expr),
        }
    },
    // Case alternative guards use -> instead of =
    <start:@L> "|" <first:GuardItem> <rest:("," <GuardItem>)*> "->" <expr:Expr> <end:@R> => {
        let mut patterns = vec![first];
        patterns.extend(rest);
        Guard {
            span: Span::new(start, end),
            patterns,
            expr: Box::new(expr),
        }
    },
};

// GuardExpr: isolated expression hierarchy for guard contexts.
// Guards use "->" as a separator (Guard: | cond -> expr), so "->" is in
// FOLLOW(GuardItem). Using a separate hierarchy (GuardExpr → GuardAppExpr →
// AtomicExpr) prevents "->" from leaking into FOLLOW(OperatorExpr), which
// would conflict with FunctionType's "->" in TypeExpr when used after "::".
GuardExpr: Expr = {
    <start:@L> <left:GuardPrefixExpr> <op:QualOperatorSpanned> <right:GuardExpr> <end:@R> => {
        Expr::Op {
            span: Span::new(start, end),
            left: Box::new(left),
            op,
            right: Box::new(right),
        }
    },
    <start:@L> <left:GuardPrefixExpr> "`" <func:GuardPrefixExpr> "`" <right:GuardExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(Expr::App {
                span: Span::new(start, end),
                func: Box::new(func),
                arg: Box::new(left),
            }),
            arg: Box::new(right),
        }
    },
    GuardPrefixExpr,
};

// Prefix expressions in guard context: negation
GuardPrefixExpr: Expr = {
    <start:@L> NegateOp <expr:GuardPrefixExpr> <end:@R> => {
        Expr::Negate {
            span: Span::new(start, end),
            expr: Box::new(expr),
        }
    },
    GuardAppExpr,
};

GuardAppExpr: Expr = {
    <AtomicExpr> => <>,
    <start:@L> <func:GuardAppExpr> <arg:AtomicExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(func),
            arg: Box::new(arg),
        }
    },
    <start:@L> <expr:GuardAppExpr> "." <field:LowerIdent> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(field, Span::new(start, end)),
        }
    },
    <start:@L> <expr:GuardAppExpr> "." <fs:@L> "type" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("type"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:GuardAppExpr> "." <fs:@L> "class" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("class"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:GuardAppExpr> "." <fs:@L> "where" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("where"), Span::new(fs, fe)),
        }
    },
};

// Guard item: either boolean condition or pattern bind (GuardExpr <- GuardExpr)
GuardItem: GuardPattern = {
    // Pattern guard: pattern <- expression (uses expr_to_binder to convert)
    <lhs:GuardExpr> "<-" <rhs:GuardExpr> =>? {
        let binder = expr_to_binder(lhs).map_err(|e| lalrpop_util::ParseError::User { error: e })?;
        Ok(GuardPattern::Pattern(binder, Box::new(rhs)))
    },
    // Boolean guard: expression
    <expr:GuardExpr> => {
        GuardPattern::Boolean(Box::new(expr))
    },
};

DataDecl: Decl = {
    // data Foo a = Bar a | Baz
    <start:@L> "data" <name:UpperIdentSpanned> <type_vars:ForallVar*> "="
    <first:DataConstructor> <rest:("|" <DataConstructor>)*> <end:@R> => {
        let mut constructors = vec![first];
        constructors.extend(rest);
        Decl::Data {
            span: Span::new(start, end),
            name,
            type_vars,
            constructors,
        }
    },
    // data Foo :: Kind (kind signature)
    <start:@L> "data" <name:UpperIdentSpanned> "::" <kind:TypeExpr> <end:@R> => {
        Decl::Data {
            span: Span::new(start, end),
            name,
            type_vars: vec![],
            constructors: vec![],
        }
    },
    // data Foo (empty declaration, no constructors — FFI types)
    <start:@L> "data" <name:UpperIdentSpanned> <type_vars:ForallVar*> <end:@R> => {
        Decl::Data {
            span: Span::new(start, end),
            name,
            type_vars,
            constructors: vec![],
        }
    },
};

DataConstructor: DataConstructor = {
    <start:@L> <name:UpperIdentSpanned> <fields:AtomicTypeExpr*> <end:@R> => {
        DataConstructor {
            span: Span::new(start, end),
            name,
            fields,
        }
    }
};

TypeAliasDecl: Decl = {
    <start:@L> "type" <name:UpperIdentSpanned> <type_vars:ForallVar*> "="
    <ty:TypeExpr> <end:@R> => {
        Decl::TypeAlias {
            span: Span::new(start, end),
            name,
            type_vars,
            ty,
        }
    },
    // Negative type-level int alias: type NegOne = -1
    <start:@L> "type" <name:UpperIdentSpanned> <type_vars:ForallVar*> "="
    <ts:@L> NegateOp <n:IntLit> <te:@R> <end:@R> => {
        Decl::TypeAlias {
            span: Span::new(start, end),
            name,
            type_vars,
            ty: TypeExpr::IntLiteral {
                span: Span::new(ts, te),
                value: -n,
            },
        }
    },
    // Kinded type alias: type Name vars = Type :: Kind
    <start:@L> "type" <name:UpperIdentSpanned> <type_vars:ForallVar*> "="
    <ty:ConstrainedType> "::" <kind:ConstrainedType> <end:@R> => {
        Decl::TypeAlias {
            span: Span::new(start, end),
            name,
            type_vars,
            ty: TypeExpr::Kinded {
                span: Span::new(start, end),
                ty: Box::new(ty),
                kind: Box::new(kind),
            },
        }
    },
    // type Foo :: Kind (kind signature — reuse Data as placeholder)
    <start:@L> "type" <name:UpperIdentSpanned> "::" <_kind:TypeExpr> <end:@R> => {
        Decl::Data {
            span: Span::new(start, end),
            name,
            type_vars: vec![],
            constructors: vec![],
        }
    },
    // type role Name role1 role2 ... — role declaration (consumed/ignored)
    <start:@L> "type" <_role:LowerIdent> <name:UpperIdentSpanned> <_roles:LowerIdent*> <end:@R> => {
        Decl::Data {
            span: Span::new(start, end),
            name,
            type_vars: vec![],
            constructors: vec![],
        }
    },
};

NewtypeDecl: Decl = {
    <start:@L> "newtype" <name:UpperIdentSpanned> <type_vars:ForallVar*> "="
    <constructor:UpperIdentSpanned> <ty:AtomicTypeExpr> <end:@R> => {
        Decl::Newtype {
            span: Span::new(start, end),
            name,
            type_vars,
            constructor,
            ty,
        }
    },
    // newtype Foo :: Kind (kind signature)
    <start:@L> "newtype" <name:UpperIdentSpanned> "::" <_kind:TypeExpr> <end:@R> => {
        Decl::Data {
            span: Span::new(start, end),
            name,
            type_vars: vec![],
            constructors: vec![],
        }
    },
};

// ===== Foreign Declarations =====

ForeignDecl: Decl = {
    // foreign import name :: Type
    <start:@L> "foreign" "import" <name:LowerIdentSpanned> "::" <ty:TypeExpr> <end:@R> => {
        Decl::Foreign {
            span: Span::new(start, end),
            name,
            ty,
        }
    },
    // foreign import data Name :: Kind
    <start:@L> "foreign" "import" "data" <name:UpperIdentSpanned> "::" <kind:TypeExpr> <end:@R> => {
        Decl::ForeignData {
            span: Span::new(start, end),
            name,
            kind,
        }
    },
};

// ===== Class Declarations =====
// Uses ClassHead to parse both constraint and class name+args with AtomicTypeExpr*.
// After ClassHead, the next token disambiguates: :: (kind sig), Operator (constraint), or other (no constraints).

// ClassHead parses an uppercase name followed by zero or more atomic type expressions.
// Returns (QualifiedIdent, name_span, args).
ClassHead: (QualifiedIdent, Span, Vec<TypeExpr>) = {
    <start:@L> <name:QualUpperIdent> <name_end:@R> <args:AtomicTypeExpr*> => {
        (name, Span::new(start, name_end), args)
    },
};

ClassDecl: Decl = {
    // class Name :: Kind (kind signature)
    <start:@L> "class" <head:ClassHead> "::" <_kind:TypeExpr> <end:@R> => {
        Decl::Class {
            span: Span::new(start, end),
            constraints: vec![],
            name: Spanned::new(head.0.name, head.1),
            type_vars: vec![],
            fundeps: vec![],
            members: vec![],
        }
    },
    // class Name args fundeps? body? (no constraints)
    <start:@L> "class" <head:ClassHead>
    <fundeps:FunDeps?> <body:ClassBody?> <end:@R> => {
        let type_vars: Vec<Spanned<Ident>> = head.2.into_iter().filter_map(|t| {
            match t {
                TypeExpr::Var { name, .. } => Some(name),
                _ => None,
            }
        }).collect();
        Decl::Class {
            span: Span::new(start, end),
            constraints: vec![],
            name: Spanned::new(head.0.name, head.1),
            type_vars,
            fundeps: fundeps.unwrap_or_default(),
            members: body.unwrap_or_default(),
        }
    },
    // class Constraint args <= Name vars fundeps? body? (single constraint)
    <start:@L> "class" <constraint_head:ClassHead> Operator
    <class_head:ClassHead>
    <fundeps:FunDeps?> <body:ClassBody?> <end:@R> => {
        let constraint = Constraint {
            span: Span::new(start, class_head.1.start),
            class: constraint_head.0,
            args: constraint_head.2,
        };
        let type_vars: Vec<Spanned<Ident>> = class_head.2.into_iter().filter_map(|t| {
            match t {
                TypeExpr::Var { name, .. } => Some(name),
                _ => None,
            }
        }).collect();
        Decl::Class {
            span: Span::new(start, end),
            constraints: vec![constraint],
            name: Spanned::new(class_head.0.name, class_head.1),
            type_vars,
            fundeps: fundeps.unwrap_or_default(),
            members: body.unwrap_or_default(),
        }
    },
    // class (C1, C2) <= Name vars fundeps? body? (multiple constraints)
    <start:@L> "class" "(" <constraints:Sep<TypeConstraint, ",">> ")" Operator
    <class_head:ClassHead>
    <fundeps:FunDeps?> <body:ClassBody?> <end:@R> => {
        let type_vars: Vec<Spanned<Ident>> = class_head.2.into_iter().filter_map(|t| {
            match t {
                TypeExpr::Var { name, .. } => Some(name),
                _ => None,
            }
        }).collect();
        Decl::Class {
            span: Span::new(start, end),
            constraints,
            name: Spanned::new(class_head.0.name, class_head.1),
            type_vars,
            fundeps: fundeps.unwrap_or_default(),
            members: body.unwrap_or_default(),
        }
    },
};

ClassBody: Vec<ClassMember> = {
    "where" "{" <members:Sep<ClassMember, ";">> "}" => members,
};

ClassMember: ClassMember = {
    <start:@L> <name:LowerIdentSpanned> "::" <ty:TypeExpr> <end:@R> => {
        ClassMember {
            span: Span::new(start, end),
            name,
            ty,
        }
    }
};

FunDeps: Vec<FunDep> = {
    "|" <deps:Sep1<FunDep, ",">> => deps,
};

FunDep: FunDep = {
    <lhs:LowerIdentOrAs+> "->" <rhs:LowerIdentOrAs+> => {
        FunDep { lhs, rhs }
    },
    // Empty LHS: | -> r (fully determined)
    "->" <rhs:LowerIdentOrAs+> => {
        FunDep { lhs: vec![], rhs }
    },
};

// LowerIdent or `as` keyword (used in fundeps where `as` is a valid type variable)
LowerIdentOrAs: Ident = {
    LowerIdent,
    "as" => crate::interner::intern("as"),
};

// ===== Instance Declarations =====

InstanceDecl: Decl = {
    // Named: instance name :: head body?
    <start:@L> "instance" <name:LowerIdentSpanned> "::"
    <head:InstanceHead> <body:InstanceBody?> <end:@R> => {
        Decl::Instance {
            span: Span::new(start, end),
            name: Some(name),
            constraints: head.0,
            class_name: head.1,
            types: head.2,
            members: body.unwrap_or_default(),
        }
    },
    // Anonymous: instance head body?
    <start:@L> "instance" <head:InstanceHeadNoLower> <body:InstanceBody?> <end:@R> => {
        Decl::Instance {
            span: Span::new(start, end),
            name: None,
            constraints: head.0,
            class_name: head.1,
            types: head.2,
            members: body.unwrap_or_default(),
        }
    },
};

// Instance head where class name starts with UpperIdent (for anonymous instances)
InstanceHeadNoLower: (Vec<Constraint>, QualifiedIdent, Vec<TypeExpr>) = {
    // No constraints: ClassName types
    <name:QualUpperIdent> <types:AtomicTypeExpr*> => {
        (vec![], name, types)
    },
    // Single constraint with args: Constraint args => ClassName types
    <cname:QualUpperIdent> <cargs:AtomicTypeExpr+> "=>" <name:QualUpperIdent> <types:AtomicTypeExpr*> => {
        let constraint = Constraint {
            span: Span::new(0, 0),
            class: cname,
            args: cargs,
        };
        (vec![constraint], name, types)
    },
    // Single constraint without args: Constraint => ClassName types
    <cname:QualUpperIdent> "=>" <name:QualUpperIdent> <types:AtomicTypeExpr*> => {
        let constraint = Constraint {
            span: Span::new(0, 0),
            class: cname,
            args: vec![],
        };
        (vec![constraint], name, types)
    },
    // Multiple constraints: (C1, C2) => ClassName types
    "(" <constraints:Sep<TypeConstraint, ",">> ")" "=>" <name:QualUpperIdent> <types:AtomicTypeExpr*> => {
        (constraints, name, types)
    },
};

// Full instance head (after ::)
InstanceHead: (Vec<Constraint>, QualifiedIdent, Vec<TypeExpr>) = {
    // No constraints: ClassName types
    <name:QualUpperIdent> <types:AtomicTypeExpr*> => {
        (vec![], name, types)
    },
    // Single constraint with args: Constraint args => ClassName types
    <cname:QualUpperIdent> <cargs:AtomicTypeExpr+> "=>" <name:QualUpperIdent> <types:AtomicTypeExpr*> => {
        let constraint = Constraint {
            span: Span::new(0, 0),
            class: cname,
            args: cargs,
        };
        (vec![constraint], name, types)
    },
    // Single constraint without args: Constraint => ClassName types
    <cname:QualUpperIdent> "=>" <name:QualUpperIdent> <types:AtomicTypeExpr*> => {
        let constraint = Constraint {
            span: Span::new(0, 0),
            class: cname,
            args: vec![],
        };
        (vec![constraint], name, types)
    },
    // Multiple constraints: (C1, C2) => ClassName types
    "(" <constraints:Sep<TypeConstraint, ",">> ")" "=>" <name:QualUpperIdent> <types:AtomicTypeExpr*> => {
        (constraints, name, types)
    },
};

InstanceBody: Vec<Decl> = {
    "where" "{" <decls:Sep<Decl, ";">> "}" => decls,
};

// ===== Derive Declarations =====

DeriveDecl: Decl = {
    // derive instance name :: head
    <start:@L> "derive" "instance" <name:LowerIdentSpanned> "::"
    <head:InstanceHead> <end:@R> => {
        Decl::Derive {
            span: Span::new(start, end),
            newtype: false,
            name: Some(name),
            constraints: head.0,
            class_name: head.1,
            types: head.2,
        }
    },
    // derive instance head (anonymous)
    <start:@L> "derive" "instance" <head:InstanceHeadNoLower> <end:@R> => {
        Decl::Derive {
            span: Span::new(start, end),
            newtype: false,
            name: None,
            constraints: head.0,
            class_name: head.1,
            types: head.2,
        }
    },
    // derive newtype instance name :: head
    <start:@L> "derive" "newtype" "instance" <name:LowerIdentSpanned> "::"
    <head:InstanceHead> <end:@R> => {
        Decl::Derive {
            span: Span::new(start, end),
            newtype: true,
            name: Some(name),
            constraints: head.0,
            class_name: head.1,
            types: head.2,
        }
    },
    // derive newtype instance head (anonymous)
    <start:@L> "derive" "newtype" "instance" <head:InstanceHeadNoLower> <end:@R> => {
        Decl::Derive {
            span: Span::new(start, end),
            newtype: true,
            name: None,
            constraints: head.0,
            class_name: head.1,
            types: head.2,
        }
    },
};

// ===== Fixity Declarations =====

FixityDecl: Decl = {
    // infixl 6 add as +
    <start:@L> <assoc:Associativity> <prec:IntLit> <target:QualIdent> "as" <op:OperatorSpanned> <end:@R> => {
        Decl::Fixity {
            span: Span::new(start, end),
            associativity: assoc,
            precedence: prec as u8,
            target,
            operator: op,
            is_type: false,
        }
    },
    // infixr 4 type NaturalTransformation as ~>
    <start:@L> <assoc:Associativity> <prec:IntLit> "type" <target:QualUpperIdent> "as" <op:OperatorSpanned> <end:@R> => {
        Decl::Fixity {
            span: Span::new(start, end),
            associativity: assoc,
            precedence: prec as u8,
            target,
            operator: op,
            is_type: true,
        }
    },
};

Associativity: Associativity = {
    "infixl" => Associativity::Left,
    "infixr" => Associativity::Right,
    "infix" => Associativity::None,
};

// ===== Expressions =====
// Hierarchy: Expr > OperatorExpr > PrefixExpr > AppExpr > AtomicExpr
// Open-ended forms (Lambda, If, Let) at Expr level
// Delimited forms (Case, Do, Record) at AtomicExpr level
// Prefix negation (-) between operators and application

pub Expr: Expr = {
    LambdaExpr,
    IfExpr,
    LetExpr,
    AdoExpr,
    QualifiedAdoExpr,
    OperatorExpr,
};

// Operator expressions (right-associative by default)
OperatorExpr: Expr = {
    <start:@L> <left:PrefixExpr> <op:QualOperatorSpanned> <right:Expr> <end:@R> => {
        Expr::Op {
            span: Span::new(start, end),
            left: Box::new(left),
            op,
            right: Box::new(right),
        }
    },
    <start:@L> <left:PrefixExpr> "`" <func:BacktickInner> "`" <right:Expr> <end:@R> => {
        // Backtick operator: a `func` b  (func can contain regular operators like $)
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(Expr::App {
                span: Span::new(start, end),
                func: Box::new(func),
                arg: Box::new(left),
            }),
            arg: Box::new(right),
        }
    },
    // Type annotation: expr :: Type
    // Uses full TypeExpr (including function arrows) because GuardExpr isolates
    // the -> token from FOLLOW(OperatorExpr), preventing FunctionType conflicts.
    <start:@L> <expr:PrefixExpr> "::" <ty:TypeExpr> <end:@R> => {
        Expr::TypeAnnotation {
            span: Span::new(start, end),
            expr: Box::new(expr),
            ty,
        }
    },
    // Chained type annotation with kind: expr :: Type :: Kind
    // For cases like `x :: _ :: Type` where the type itself has a kind annotation.
    <start:@L> <expr:PrefixExpr> "::" <ty:ConstrainedType> "::" <kind:TypeExpr> <end:@R> => {
        Expr::TypeAnnotation {
            span: Span::new(start, end),
            expr: Box::new(expr),
            ty: TypeExpr::Kinded {
                span: Span::new(start, end),
                ty: Box::new(ty),
                kind: Box::new(kind),
            },
        }
    },
    // Trailing open-ended expression as last application argument:
    // f \x -> x, f if c then a else b, f let x = 1 in x, f ado x <- y in z
    <start:@L> <func:PrefixExpr> <arg:LambdaExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(func),
            arg: Box::new(arg),
        }
    },
    <start:@L> <func:PrefixExpr> <arg:IfExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(func),
            arg: Box::new(arg),
        }
    },
    <start:@L> <func:PrefixExpr> <arg:LetExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(func),
            arg: Box::new(arg),
        }
    },
    <start:@L> <func:PrefixExpr> <arg:AdoExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(func),
            arg: Box::new(arg),
        }
    },
    <start:@L> <func:PrefixExpr> <arg:QualifiedAdoExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(func),
            arg: Box::new(arg),
        }
    },
    PrefixExpr,
};

// Expression between backticks: allows regular operators (like $) but NOT nested backticks.
// This avoids ambiguity between inner backtick operators and the closing backtick delimiter.
BacktickInner: Expr = {
    <start:@L> <left:PrefixExpr> <op:QualOperatorSpanned> <right:BacktickInner> <end:@R> => {
        Expr::Op {
            span: Span::new(start, end),
            left: Box::new(left),
            op,
            right: Box::new(right),
        }
    },
    PrefixExpr,
};

// Prefix expressions: negation
PrefixExpr: Expr = {
    <start:@L> NegateOp <expr:PrefixExpr> <end:@R> => {
        Expr::Negate {
            span: Span::new(start, end),
            expr: Box::new(expr),
        }
    },
    AppExpr,
};

// Function application: f x y (left-associative)
AppExpr: Expr = {
    <AtomicExpr> => <>,
    <start:@L> <func:AppExpr> <arg:AtomicExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(func),
            arg: Box::new(arg),
        }
    },
    // Record access: expr.field
    <start:@L> <expr:AppExpr> "." <field:LowerIdent> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(field, Span::new(start, end)),
        }
    },
    // Visible type application / as-pattern: expr @arg
    // Parses arg as AtomicTypeExpr directly. In binder context (do-bind),
    // expr_to_binder converts VisibleTypeApp to Binder::As via type_to_binder.
    <start:@L> <func:AppExpr> "@" <arg:AtomicTypeExpr> <end:@R> => {
        Expr::VisibleTypeApp {
            span: Span::new(start, end),
            func: Box::new(func),
            ty: arg,
        }
    },
    // Record access with reserved word field: expr.type, expr.class, etc.
    <start:@L> <expr:AppExpr> "." <fs:@L> "type" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("type"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "class" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("class"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "data" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("data"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "module" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("module"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "where" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("where"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "if" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("if"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "as" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("as"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "export" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("export"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "hiding" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("hiding"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "else" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("else"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "then" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("then"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "case" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("case"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "of" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("of"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "let" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("let"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "in" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("in"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "instance" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("instance"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "derive" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("derive"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "newtype" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("newtype"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "foreign" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("foreign"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "import" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("import"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "forall" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("forall"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "true" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("true"), Span::new(fs, fe)),
        }
    },
    <start:@L> <expr:AppExpr> "." <fs:@L> "false" <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern("false"), Span::new(fs, fe)),
        }
    },
    // String literal field access: obj."fieldName"
    <start:@L> <expr:AppExpr> "." <fs:@L> <s:StringLit> <fe:@R> <end:@R> => {
        Expr::RecordAccess {
            span: Span::new(start, end),
            expr: Box::new(expr),
            field: Spanned::new(crate::interner::intern(&s), Span::new(fs, fe)),
        }
    },
    // Qualified operator in parens: Module.(+)
    <start:@L> <expr:AppExpr> "." "(" <op:Operator> ")" <end:@R> => {
        let module = match &expr {
            Expr::Constructor { name, .. } => Some(name.name),
            _ => None,
        };
        Expr::OpParens {
            span: Span::new(start, end),
            op: Spanned::new(QualifiedIdent { module, name: op }, Span::new(start, end)),
        }
    },
    // Qualified special operator in parens: Module.(:) Module.(~)
    <start:@L> <expr:AppExpr> "." "(" ":" ")" <end:@R> => {
        let module = match &expr {
            Expr::Constructor { name, .. } => Some(name.name),
            _ => None,
        };
        Expr::OpParens {
            span: Span::new(start, end),
            op: Spanned::new(QualifiedIdent { module, name: crate::interner::intern(":") }, Span::new(start, end)),
        }
    },
    <start:@L> <expr:AppExpr> "." "(" "~" ")" <end:@R> => {
        let module = match &expr {
            Expr::Constructor { name, .. } => Some(name.name),
            _ => None,
        };
        Expr::OpParens {
            span: Span::new(start, end),
            op: Spanned::new(QualifiedIdent { module, name: crate::interner::intern("~") }, Span::new(start, end)),
        }
    },
};

// Atomic expressions (highest precedence, self-delimiting)
AtomicExpr: Expr = {
    LiteralExpr,
    VarExpr,
    ConstructorExpr,
    HoleExpr,
    ParensExpr,
    CaseExpr,
    DoExpr,
    RecordExpr,
    ArrayExpr,
    // Empty parens: () — used as an expression (rare; mainly appears after @ which now uses AtomicTypeExpr)
    <start:@L> "(" ")" <end:@R> => {
        Expr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name: crate::interner::intern("()") },
        }
    },
    // Underscore section: _ in expression position
    <start:@L> "_" <end:@R> => {
        Expr::Hole {
            span: Span::new(start, end),
            name: crate::interner::intern("_"),
        }
    },
};

LambdaExpr: Expr = {
    <start:@L> "\\" <binders:AtomicBinder+> "->" <body:Expr> <end:@R> => {
        Expr::Lambda {
            span: Span::new(start, end),
            binders,
            body: Box::new(body),
        }
    }
};

IfExpr: Expr = {
    <start:@L> "if" <cond:Expr> "then" <then_expr:Expr> "else" <else_expr:Expr> <end:@R> => {
        Expr::If {
            span: Span::new(start, end),
            cond: Box::new(cond),
            then_expr: Box::new(then_expr),
            else_expr: Box::new(else_expr),
        }
    }
};

LetExpr: Expr = {
    <start:@L> "let" "{" <bindings:Sep<LetBinding, ";">> "}" "in" <body:Expr> <end:@R> => {
        Expr::Let {
            span: Span::new(start, end),
            bindings,
            body: Box::new(body),
        }
    }
};

LiteralExpr: Expr = {
    <start:@L> <lit:Literal> <end:@R> => {
        Expr::Literal {
            span: Span::new(start, end),
            lit,
        }
    }
};

VarExpr: Expr = {
    <start:@L> <name:LowerIdent> <end:@R> => {
        Expr::Var {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name },
        }
    },
    <start:@L> <qual:QualifiedLower> <end:@R> => {
        Expr::Var {
            span: Span::new(start, end),
            name: QualifiedIdent { module: Some(qual.0), name: qual.1 },
        }
    },
    // Contextual keywords — valid as identifier in expression position
    <start:@L> "as" <end:@R> => {
        Expr::Var {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name: crate::interner::intern("as") },
        }
    },
    <start:@L> "hiding" <end:@R> => {
        Expr::Var {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name: crate::interner::intern("hiding") },
        }
    },
    <start:@L> "export" <end:@R> => {
        Expr::Var {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name: crate::interner::intern("export") },
        }
    },
};

ConstructorExpr: Expr = {
    <start:@L> <name:UpperIdent> <end:@R> => {
        Expr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name },
        }
    },
    <start:@L> <qual:QualifiedUpper> <end:@R> => {
        Expr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: Some(qual.0), name: qual.1 },
        }
    },
};

HoleExpr: Expr = {
    <start:@L> <name:HoleLit> <end:@R> => {
        Expr::Hole {
            span: Span::new(start, end),
            name,
        }
    }
};

ParensExpr: Expr = {
    <start:@L> "(" <expr:Expr> ")" <end:@R> => {
        Expr::Parens {
            span: Span::new(start, end),
            expr: Box::new(expr),
        }
    },
    // Operator in parens: (+) or (:) or (~)
    <start:@L> "(" <op:QualOperatorSpanned> ")" <end:@R> => {
        Expr::OpParens {
            span: Span::new(start, end),
            op,
        }
    },
};

CaseExpr: Expr = {
    // Single scrutinee (also handles `case _ of` lambda-case via underscore check)
    <start:@L> "case" <expr:Expr> "of"
    "{" <alts:Sep<CaseAlternative, ";">> "}"
    <end:@R> => {
        let span = Span::new(start, end);
        // Check for lambda-case: case _ of ... → \$case -> case $case of ...
        let is_underscore = matches!(&expr, Expr::Hole { name, .. }
            if crate::interner::resolve(*name).as_deref() == Some("_"));
        if is_underscore {
            let param = crate::interner::intern("$case");
            Expr::Lambda {
                span,
                binders: vec![Binder::Var { span, name: Spanned::new(param, span) }],
                body: Box::new(Expr::Case {
                    span,
                    exprs: vec![Expr::Var { span, name: QualifiedIdent { module: None, name: param } }],
                    alts,
                }),
            }
        } else {
            Expr::Case { span, exprs: vec![expr], alts }
        }
    },
    // Multiple scrutinees: case a, b of ...
    <start:@L> "case" <first:Expr> "," <rest:Sep1<Expr, ",">> "of"
    "{" <alts:Sep<CaseAlternative, ";">> "}"
    <end:@R> => {
        let mut exprs = vec![first];
        exprs.extend(rest);
        Expr::Case {
            span: Span::new(start, end),
            exprs,
            alts,
        }
    },
};

CaseAlternative: CaseAlternative = {
    <start:@L> <binders:Sep1<Binder, ",">> "->" <expr:Expr> <wc:WhereClause?> <end:@R> => {
        let final_expr = if let Some(bindings) = wc {
            Expr::Let { span: Span::new(start, end), bindings, body: Box::new(expr) }
        } else {
            expr
        };
        CaseAlternative {
            span: Span::new(start, end),
            binders,
            result: GuardedExpr::Unconditional(Box::new(final_expr)),
        }
    },
    <start:@L> <binders:Sep1<Binder, ",">> <guards:Guard+> <end:@R> => {
        CaseAlternative {
            span: Span::new(start, end),
            binders,
            result: GuardedExpr::Guarded(guards),
        }
    },
};

LetBinding: LetBinding = {
    // Value binding: name binders* = expr OR pattern = expr
    // When name is LowerIdent with binders, it's a function definition: f x y = expr
    // When there are no binders and it's just a pattern: pattern = expr
    <start:@L> <binder:AtomicBinder> <extra_binders:AtomicBinder*> "=" <expr:Expr> <wc:WhereClause?> <end:@R> => {
        // Wrap expr with where clause if present
        let final_expr = if let Some(bindings) = wc {
            Expr::Let { span: Span::new(start, end), bindings, body: Box::new(expr) }
        } else {
            expr
        };
        if extra_binders.is_empty() {
            LetBinding::Value {
                span: Span::new(start, end),
                binder,
                expr: final_expr,
            }
        } else {
            // Multi-arg function: desugar to lambda
            let name = match &binder {
                Binder::Var { name, .. } => name.clone(),
                _ => Spanned::new(crate::interner::intern("_"), Span::new(start, end)),
            };
            let lambda = Expr::Lambda {
                span: Span::new(start, end),
                binders: extra_binders,
                body: Box::new(final_expr),
            };
            LetBinding::Value {
                span: Span::new(start, end),
                binder: Binder::Var { span: name.span, name },
                expr: lambda,
            }
        }
    },
    // Guarded binding: f binders | cond = expr | cond2 = expr2
    // Per-guard where clauses are handled inside each Guard.
    <start:@L> <binder:AtomicBinder> <extra_binders:AtomicBinder*> <guards:Guard+> <end:@R> => {
        // For guarded bindings, desugar to a simple value for now
        let first_guard = &guards[0];
        let final_expr = if extra_binders.is_empty() {
            first_guard.expr.as_ref().clone()
        } else {
            let name = match &binder {
                Binder::Var { name, .. } => name.clone(),
                _ => Spanned::new(crate::interner::intern("_"), Span::new(start, end)),
            };
            Expr::Lambda {
                span: Span::new(start, end),
                binders: extra_binders,
                body: first_guard.expr.clone(),
            }
        };
        LetBinding::Value {
            span: Span::new(start, end),
            binder,
            expr: final_expr,
        }
    },
    // Operator pattern binding: a /\ b = expr
    <start:@L> <left:AtomicBinder> <op:OperatorSpanned> <right:Binder> "=" <expr:Expr> <end:@R> => {
        LetBinding::Value {
            span: Span::new(start, end),
            binder: Binder::Op {
                span: Span::new(start, end),
                left: Box::new(left),
                op,
                right: Box::new(right),
            },
            expr,
        }
    },
    // Type signature: name :: Type
    <start:@L> <name:LowerIdentSpanned> "::" <ty:TypeExpr> <end:@R> => {
        LetBinding::Signature {
            span: Span::new(start, end),
            name,
            ty,
        }
    },
};

DoExpr: Expr = {
    <start:@L> "do" "{" <statements:Sep1<DoStatement, ";">> "}" <end:@R> => {
        Expr::Do {
            span: Span::new(start, end),
            module: None,
            statements,
        }
    },
    <start:@L> <module:QualifiedDo> "{" <statements:Sep1<DoStatement, ";">> "}" <end:@R> => {
        Expr::Do {
            span: Span::new(start, end),
            module: Some(module),
            statements,
        }
    },
};

AdoExpr: Expr = {
    <start:@L> "ado" "{" <statements:Sep<DoStatement, ";">> "}" "in" <body:Expr> <end:@R> => {
        Expr::Ado {
            span: Span::new(start, end),
            module: None,
            statements,
            result: Box::new(body),
        }
    }
};

QualifiedAdoExpr: Expr = {
    <start:@L> <module:QualifiedAdo> "{" <statements:Sep<DoStatement, ";">> "}" "in" <body:Expr> <end:@R> => {
        Expr::Ado {
            span: Span::new(start, end),
            module: Some(module),
            statements,
            result: Box::new(body),
        }
    }
};

DoStatement: DoStatement = {
    // Bind: expr <- expr (left side reinterpreted as binder)
    <start:@L> <lhs:Expr> "<-" <rhs:Expr> <end:@R> =>? {
        let binder = expr_to_binder(lhs).map_err(|e| lalrpop_util::ParseError::User { error: e })?;
        Ok(DoStatement::Bind {
            span: Span::new(start, end),
            binder,
            expr: rhs,
        })
    },
    <start:@L> "let" "{" <bindings:Sep<LetBinding, ";">> "}" <end:@R> => {
        DoStatement::Let {
            span: Span::new(start, end),
            bindings,
        }
    },
    <start:@L> <expr:Expr> <end:@R> => {
        DoStatement::Discard {
            span: Span::new(start, end),
            expr,
        }
    },
};

// Record expression: inlined to avoid Sep empty case with LowerIdent
RecordExpr: Expr = {
    <start:@L> "{" "}" <end:@R> => {
        Expr::Record {
            span: Span::new(start, end),
            fields: vec![],
        }
    },
    // Row extension record: { | r } — used in visible type applications like Proxy @(ctx' { | r })
    <start:@L> "{" "|" <_var:Expr> "}" <end:@R> => {
        Expr::Record {
            span: Span::new(start, end),
            fields: vec![],
        }
    },
    <start:@L> "{" <first:RecordField> <rest:("," <RecordField>)*> "}" <end:@R> => {
        let mut fields = vec![first];
        fields.extend(rest);
        Expr::Record {
            span: Span::new(start, end),
            fields,
        }
    },
};

RecordField: RecordField = {
    <start:@L> <label:RecordLabel> ":" <value:Expr> <end:@R> => {
        RecordField {
            span: Span::new(start, end),
            label,
            value: Some(value),
            type_ann: None,
        }
    },
    // Record update field: { field = value }
    <start:@L> <label:RecordLabel> "=" <value:Expr> <end:@R> => {
        RecordField {
            span: Span::new(start, end),
            label,
            value: Some(value),
            type_ann: None,
        }
    },
    // Record type field: { field :: Type } (for visible type application via @)
    <start:@L> <label:RecordLabel> "::" <ty:TypeExpr> <end:@R> => {
        RecordField {
            span: Span::new(start, end),
            label,
            value: None,
            type_ann: Some(ty),
        }
    },
    // Record pun: { x } is shorthand for { x: x }
    <start:@L> <label:LowerIdentSpanned> <end:@R> => {
        RecordField {
            span: Span::new(start, end),
            label,
            value: None,
            type_ann: None,
        }
    },
    // Nested record update: { field { subfield = value } }
    <start:@L> <label:RecordLabel> "{" <first:RecordField> <rest:("," <RecordField>)*> "}" <end:@R> => {
        let mut inner_fields = vec![first];
        inner_fields.extend(rest);
        RecordField {
            span: Span::new(start, end),
            label,
            value: Some(Expr::Record {
                span: Span::new(start, end),
                fields: inner_fields,
            }),
            type_ann: None,
        }
    },
};

// Record label — lower ident or reserved word used as field name
RecordLabel: Spanned<Ident> = {
    LowerIdentSpanned,
    <start:@L> "type" <end:@R> => Spanned::new(crate::interner::intern("type"), Span::new(start, end)),
    <start:@L> "class" <end:@R> => Spanned::new(crate::interner::intern("class"), Span::new(start, end)),
    <start:@L> "data" <end:@R> => Spanned::new(crate::interner::intern("data"), Span::new(start, end)),
    <start:@L> "module" <end:@R> => Spanned::new(crate::interner::intern("module"), Span::new(start, end)),
    <start:@L> "where" <end:@R> => Spanned::new(crate::interner::intern("where"), Span::new(start, end)),
    <start:@L> "do" <end:@R> => Spanned::new(crate::interner::intern("do"), Span::new(start, end)),
    <start:@L> "if" <end:@R> => Spanned::new(crate::interner::intern("if"), Span::new(start, end)),
    <start:@L> "then" <end:@R> => Spanned::new(crate::interner::intern("then"), Span::new(start, end)),
    <start:@L> "else" <end:@R> => Spanned::new(crate::interner::intern("else"), Span::new(start, end)),
    <start:@L> "import" <end:@R> => Spanned::new(crate::interner::intern("import"), Span::new(start, end)),
    <start:@L> "instance" <end:@R> => Spanned::new(crate::interner::intern("instance"), Span::new(start, end)),
    <start:@L> "derive" <end:@R> => Spanned::new(crate::interner::intern("derive"), Span::new(start, end)),
    <start:@L> "newtype" <end:@R> => Spanned::new(crate::interner::intern("newtype"), Span::new(start, end)),
    <start:@L> "foreign" <end:@R> => Spanned::new(crate::interner::intern("foreign"), Span::new(start, end)),
    <start:@L> "forall" <end:@R> => Spanned::new(crate::interner::intern("forall"), Span::new(start, end)),
    <start:@L> "case" <end:@R> => Spanned::new(crate::interner::intern("case"), Span::new(start, end)),
    <start:@L> "of" <end:@R> => Spanned::new(crate::interner::intern("of"), Span::new(start, end)),
    <start:@L> "let" <end:@R> => Spanned::new(crate::interner::intern("let"), Span::new(start, end)),
    <start:@L> "in" <end:@R> => Spanned::new(crate::interner::intern("in"), Span::new(start, end)),
    <start:@L> "true" <end:@R> => Spanned::new(crate::interner::intern("true"), Span::new(start, end)),
    <start:@L> "false" <end:@R> => Spanned::new(crate::interner::intern("false"), Span::new(start, end)),
    <start:@L> "ado" <end:@R> => Spanned::new(crate::interner::intern("ado"), Span::new(start, end)),
    <start:@L> "infix" <end:@R> => Spanned::new(crate::interner::intern("infix"), Span::new(start, end)),
    <start:@L> "infixl" <end:@R> => Spanned::new(crate::interner::intern("infixl"), Span::new(start, end)),
    <start:@L> "infixr" <end:@R> => Spanned::new(crate::interner::intern("infixr"), Span::new(start, end)),
    // Note: "hiding" and "export" are covered by LowerIdentSpanned (contextual keywords)
    // String literal as record label: { "field name": value }
    <start:@L> <s:StringLit> <end:@R> => Spanned::new(crate::interner::intern(&s), Span::new(start, end)),
};

// Array expression: inlined to avoid Sep empty case
ArrayExpr: Expr = {
    <start:@L> "[" "]" <end:@R> => {
        Expr::Array {
            span: Span::new(start, end),
            elements: vec![],
        }
    },
    <start:@L> "[" <first:Expr> <rest:("," <Expr>)*> "]" <end:@R> => {
        let mut elements = vec![first];
        elements.extend(rest);
        Expr::Array {
            span: Span::new(start, end),
            elements,
        }
    },
};

// ===== Patterns/Binders =====

Binder: Binder = {
    AppBinder,
    // Infix operator pattern: a /\ b, x :| xs (right-associative)
    <start:@L> <left:AppBinder> <op:OperatorSpanned> <right:Binder> <end:@R> => {
        Binder::Op {
            span: Span::new(start, end),
            left: Box::new(left),
            op,
            right: Box::new(right),
        }
    },
};

// Application-level binder: constructor with args, or atomic
AppBinder: Binder = {
    AtomicBinder,
    <start:@L> <name:UpperIdent> <args:AtomicBinder+> <end:@R> => {
        Binder::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name },
            args,
        }
    },
    <start:@L> <qual:QualifiedUpper> <args:AtomicBinder+> <end:@R> => {
        Binder::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: Some(qual.0), name: qual.1 },
            args,
        }
    },
    // Negative literal pattern: -42, -3.14
    <start:@L> NegateOp <n:IntLit> <end:@R> => {
        Binder::Literal {
            span: Span::new(start, end),
            lit: Literal::Int(-n),
        }
    },
    <start:@L> NegateOp <n:FloatLit> <end:@R> => {
        Binder::Literal {
            span: Span::new(start, end),
            lit: Literal::Float(-n),
        }
    },
};

AtomicBinder: Binder = {
    <start:@L> "_" <end:@R> => {
        Binder::Wildcard {
            span: Span::new(start, end),
        }
    },
    <start:@L> <name:LowerIdentSpanned> <end:@R> => {
        Binder::Var {
            span: Span::new(start, end),
            name,
        }
    },
    // As-pattern in atomic position: x@(Just y)
    <start:@L> <name:LowerIdentSpanned> "@" <binder:AtomicBinder> <end:@R> => {
        Binder::As {
            span: Span::new(start, end),
            name,
            binder: Box::new(binder),
        }
    },
    <start:@L> <lit:Literal> <end:@R> => {
        Binder::Literal {
            span: Span::new(start, end),
            lit,
        }
    },
    <start:@L> <name:UpperIdent> <end:@R> => {
        Binder::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name },
            args: vec![],
        }
    },
    <start:@L> <qual:QualifiedUpper> <end:@R> => {
        Binder::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: Some(qual.0), name: qual.1 },
            args: vec![],
        }
    },
    <start:@L> "(" <binder:Binder> ")" <end:@R> => {
        Binder::Parens {
            span: Span::new(start, end),
            binder: Box::new(binder),
        }
    },
    // Type-annotated pattern: (x :: Type)
    <start:@L> "(" <binder:Binder> "::" <ty:TypeExpr> ")" <end:@R> => {
        Binder::Typed {
            span: Span::new(start, end),
            binder: Box::new(binder),
            ty,
        }
    },
    // Record pattern: { x, y: z } — inlined to avoid Sep empty case
    <start:@L> "{" "}" <end:@R> => {
        Binder::Record {
            span: Span::new(start, end),
            fields: vec![],
        }
    },
    <start:@L> "{" <first:RecordBinderField> <rest:("," <RecordBinderField>)*> "}" <end:@R> => {
        let mut fields = vec![first];
        fields.extend(rest);
        Binder::Record {
            span: Span::new(start, end),
            fields,
        }
    },
    // Array pattern: [a, b, c]
    <start:@L> "[" "]" <end:@R> => {
        Binder::Array {
            span: Span::new(start, end),
            elements: vec![],
        }
    },
    <start:@L> "[" <first:Binder> <rest:("," <Binder>)*> "]" <end:@R> => {
        let mut elements = vec![first];
        elements.extend(rest);
        Binder::Array {
            span: Span::new(start, end),
            elements,
        }
    },
};

RecordBinderField: RecordBinderField = {
    <start:@L> <label:RecordLabel> ":" <binder:Binder> <end:@R> => {
        RecordBinderField {
            span: Span::new(start, end),
            label,
            binder: Some(binder),
        }
    },
    // Pun: { x } binds x to the field x
    <start:@L> <label:LowerIdentSpanned> <end:@R> => {
        RecordBinderField {
            span: Span::new(start, end),
            label,
            binder: None,
        }
    },
};

// ===== Types =====
// Hierarchy: TypeExpr > ForallType > ConstrainedType > FunctionType > TypeOpExpr > TypeAppExpr > AtomicTypeExpr

pub TypeExpr: TypeExpr = {
    ForallType,
    ConstrainedType,
};

ForallType: TypeExpr = {
    <start:@L> "forall" <vars:ForallVar+> "." <ty:TypeExpr> <end:@R> => {
        TypeExpr::Forall {
            span: Span::new(start, end),
            vars,
            ty: Box::new(ty),
        }
    }
};

// Forall variable: either plain `a`, visible `@a`, or kinded `(a :: Type)`
ForallVar: Spanned<Ident> = {
    LowerIdentSpanned,
    // Visible type application: @a
    "@" <name:LowerIdentSpanned> => name,
    // Kinded: (a :: Type) — we just extract the name and ignore the kind for now
    "(" <name:LowerIdentSpanned> "::" <_kind:TypeExpr> ")" => name,
    // Visible kinded: (@f :: forall a. a -> a)
    "(" "@" <name:LowerIdentSpanned> "::" <_kind:TypeExpr> ")" => name,
};

ConstrainedType: TypeExpr = {
    FunctionType,
    // Single constraint: Show a => Type (also handles chained: Show a => Eq a => ...)
    <start:@L> <head:TypeAppExpr> "=>" <ty:TypeExpr> <end:@R> => {
        let constraint = type_to_constraint(head, Span::new(start, end));
        TypeExpr::Constrained {
            span: Span::new(start, end),
            constraints: vec![constraint],
            ty: Box::new(ty),
        }
    },
};

FunctionType: TypeExpr = {
    <TypeOpExpr> => <>,
    // Allow TypeExpr (including ForallType) as RHS for higher-rank types: String -> forall a. a
    <start:@L> <from:TypeOpExpr> "->" <to:TypeExpr> <end:@R> => {
        TypeExpr::Function {
            span: Span::new(start, end),
            from: Box::new(from),
            to: Box::new(to),
        }
    }
};

// Type-level operator expressions
TypeOpExpr: TypeExpr = {
    <TypeAppExpr> => <>,
    <start:@L> <left:TypeAppExpr> <op:QualOperatorSpanned> <right:TypeOpExpr> <end:@R> => {
        TypeExpr::TypeOp {
            span: Span::new(start, end),
            left: Box::new(left),
            op,
            right: Box::new(right),
        }
    }
};

TypeAppExpr: TypeExpr = {
    <AtomicTypeExpr> => <>,
    <start:@L> <constructor:TypeAppExpr> <arg:AtomicTypeExpr> <end:@R> => {
        TypeExpr::App {
            span: Span::new(start, end),
            constructor: Box::new(constructor),
            arg: Box::new(arg),
        }
    }
};

AtomicTypeExpr: TypeExpr = {
    <start:@L> <name:LowerIdentSpanned> <end:@R> => {
        TypeExpr::Var {
            span: Span::new(start, end),
            name,
        }
    },
    <start:@L> <name:UpperIdent> <end:@R> => {
        TypeExpr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name },
        }
    },
    <start:@L> <qual:QualifiedUpper> <end:@R> => {
        TypeExpr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: Some(qual.0), name: qual.1 },
        }
    },
    <start:@L> "(" <ty:TypeExpr> ")" <end:@R> => {
        TypeExpr::Parens {
            span: Span::new(start, end),
            ty: Box::new(ty),
        }
    },
    <start:@L> <name:HoleLit> <end:@R> => {
        TypeExpr::Hole {
            span: Span::new(start, end),
            name,
        }
    },
    // Wildcard type: _
    <start:@L> "_" <end:@R> => {
        TypeExpr::Wildcard {
            span: Span::new(start, end),
        }
    },
    // Record type: { x :: Int, y :: String } or { x :: Int | r }
    <start:@L> "{" <fields:Sep<TypeField, ",">> <tail:("|" <TypeExpr>)?> "}" <end:@R> => {
        if let Some(tail) = tail {
            TypeExpr::Row {
                span: Span::new(start, end),
                fields,
                tail: Some(Box::new(tail)),
            }
        } else {
            TypeExpr::Record {
                span: Span::new(start, end),
                fields,
            }
        }
    },
    // Type-level string literal
    <start:@L> <s:StringLit> <end:@R> => {
        TypeExpr::StringLiteral {
            span: Span::new(start, end),
            value: s,
        }
    },
    // Type-level int literal
    <start:@L> <n:IntLit> <end:@R> => {
        TypeExpr::IntLiteral {
            span: Span::new(start, end),
            value: n,
        }
    },
    // (->) as a type constructor in parens
    <start:@L> "(" "->" ")" <end:@R> => {
        TypeExpr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name: crate::interner::intern("->") },
        }
    },
    // Row type in parens: (label :: Type, ... | rest)
    <start:@L> "(" <label:RecordLabel> "::" <ty:TypeExpr>
    <rest:("," <TypeField>)*> <tail:("|" <TypeExpr>)?> ")" <end:@R> => {
        let mut fields = vec![TypeField { span: label.span, label, ty }];
        fields.extend(rest);
        TypeExpr::Row {
            span: Span::new(start, end),
            fields,
            tail: tail.map(Box::new),
        }
    },
    // Empty row type with tail: (| r)
    <start:@L> "(" "|" <tail:TypeExpr> ")" <end:@R> => {
        TypeExpr::Row {
            span: Span::new(start, end),
            fields: vec![],
            tail: Some(Box::new(tail)),
        }
    },
    // Empty row type: ()
    <start:@L> "(" ")" <end:@R> => {
        TypeExpr::Row {
            span: Span::new(start, end),
            fields: vec![],
            tail: None,
        }
    },
    // Type keyword as type constructor (for kinds like `Row Type`)
    <start:@L> "type" <end:@R> => {
        TypeExpr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name: crate::interner::intern("Type") },
        }
    },
    // Operator as type constructor in parens: (~>), (/\), etc.
    <start:@L> "(" <op:Operator> ")" <end:@R> => {
        TypeExpr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name: op },
        }
    },
    // Tilde as type constructor in parens: (~)
    <start:@L> "(" "~" ")" <end:@R> => {
        TypeExpr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name: crate::interner::intern("~") },
        }
    },
    // Negative type-level integer in parens: (-42)
    <start:@L> "(" <is:@L> NegateOp <n:IntLit> <ie:@R> ")" <end:@R> => {
        TypeExpr::IntLiteral {
            span: Span::new(start, end),
            value: -n,
        }
    },
    // Kinded type in parens where LHS is negative int: ((-42) :: Int)
    <start:@L> "(" <is:@L> "(" NegateOp <n:IntLit> ")" <ie:@R> "::" <kind:TypeExpr> ")" <end:@R> => {
        TypeExpr::Kinded {
            span: Span::new(start, end),
            ty: Box::new(TypeExpr::IntLiteral {
                span: Span::new(is, ie),
                value: -n,
            }),
            kind: Box::new(kind),
        }
    },
    // Kinded type in parens where LHS is parenthesized: ((a) :: Type)
    <start:@L> "(" <is:@L> "(" <ty:TypeExpr> ")" <ie:@R> "::" <kind:TypeExpr> ")" <end:@R> => {
        TypeExpr::Kinded {
            span: Span::new(start, end),
            ty: Box::new(TypeExpr::Parens {
                span: Span::new(is, ie),
                ty: Box::new(ty),
            }),
            kind: Box::new(kind),
        }
    },
    // Kinded type in parens where LHS is int literal: (42 :: Int)
    <start:@L> "(" <is:@L> <n:IntLit> <ie:@R> "::" <kind:TypeExpr> ")" <end:@R> => {
        TypeExpr::Kinded {
            span: Span::new(start, end),
            ty: Box::new(TypeExpr::IntLiteral {
                span: Span::new(is, ie),
                value: n,
            }),
            kind: Box::new(kind),
        }
    },
    // Kinded type in parens where LHS is wildcard: (_ :: Type)
    <start:@L> "(" <is:@L> "_" <ie:@R> "::" <kind:TypeExpr> ")" <end:@R> => {
        TypeExpr::Kinded {
            span: Span::new(start, end),
            ty: Box::new(TypeExpr::Wildcard {
                span: Span::new(is, ie),
            }),
            kind: Box::new(kind),
        }
    },
    // Kinded type in parens where LHS is upper ident: (Type :: Kind)
    <start:@L> "(" <is:@L> <name:UpperIdent> <ie:@R> "::" <kind:TypeExpr> ")" <end:@R> => {
        TypeExpr::Kinded {
            span: Span::new(start, end),
            ty: Box::new(TypeExpr::Constructor {
                span: Span::new(is, ie),
                name: QualifiedIdent { module: None, name },
            }),
            kind: Box::new(kind),
        }
    },
    // Kinded type in parens where LHS is qualified upper: (Module.Type :: Kind)
    <start:@L> "(" <is:@L> <qual:QualifiedUpper> <ie:@R> "::" <kind:TypeExpr> ")" <end:@R> => {
        TypeExpr::Kinded {
            span: Span::new(start, end),
            ty: Box::new(TypeExpr::Constructor {
                span: Span::new(is, ie),
                name: QualifiedIdent { module: Some(qual.0), name: qual.1 },
            }),
            kind: Box::new(kind),
        }
    },
};

TypeField: TypeField = {
    <start:@L> <label:RecordLabel> "::" <ty:TypeExpr> <end:@R> => {
        TypeField {
            span: Span::new(start, end),
            label,
            ty,
        }
    },
    // Shorthand: just a label without :: (for as-pattern records parsed as types in @ context)
    <start:@L> <name:LowerIdentSpanned> <end:@R> => {
        TypeField {
            span: Span::new(start, end),
            label: name,
            ty: TypeExpr::Wildcard { span: Span::new(start, end) },
        }
    },
};

TypeConstraint: Constraint = {
    <start:@L> <name:UpperIdent> <args:AtomicTypeExpr*> <end:@R> => {
        Constraint {
            span: Span::new(start, end),
            class: QualifiedIdent { module: None, name },
            args,
        }
    },
    <start:@L> <qual:QualifiedUpper> <args:AtomicTypeExpr*> <end:@R> => {
        Constraint {
            span: Span::new(start, end),
            class: QualifiedIdent { module: Some(qual.0), name: qual.1 },
            args,
        }
    },
};

// ===== Literals =====

Literal: Literal = {
    <IntLit> => Literal::Int(<>),
    <FloatLit> => Literal::Float(<>),
    <StringLit> => Literal::String(<>),
    <CharLit> => Literal::Char(<>),
    "true" => Literal::Boolean(true),
    "false" => Literal::Boolean(false),
};

// ===== Identifier helpers =====

LowerIdentSpanned: Spanned<Ident> = {
    <start:@L> <name:LowerIdent> <end:@R> => {
        Spanned::new(name, Span::new(start, end))
    },
    // Contextual keywords — valid as identifier everywhere except their special contexts
    <start:@L> "as" <end:@R> => {
        Spanned::new(crate::interner::intern("as"), Span::new(start, end))
    },
    <start:@L> "hiding" <end:@R> => {
        Spanned::new(crate::interner::intern("hiding"), Span::new(start, end))
    },
    <start:@L> "export" <end:@R> => {
        Spanned::new(crate::interner::intern("export"), Span::new(start, end))
    },
};

UpperIdentSpanned: Spanned<Ident> = {
    <start:@L> <name:UpperIdent> <end:@R> => {
        Spanned::new(name, Span::new(start, end))
    }
};

OperatorSpanned: Spanned<Ident> = {
    <start:@L> <op:Operator> <end:@R> => {
        Spanned::new(op, Span::new(start, end))
    },
    <start:@L> <qual:QualifiedOperator> <end:@R> => {
        Spanned::new(qual.1, Span::new(start, end))
    },
    // Special tokens that act as operators in expressions
    <start:@L> ":" <end:@R> => {
        Spanned::new(crate::interner::intern(":"), Span::new(start, end))
    },
    <start:@L> "~" <end:@R> => {
        Spanned::new(crate::interner::intern("~"), Span::new(start, end))
    },
};

// Qualified operator with module info, for Expr::Op and TypeExpr::TypeOp
QualOperatorSpanned: Spanned<QualifiedIdent> = {
    <start:@L> <op:Operator> <end:@R> => {
        Spanned::new(QualifiedIdent { module: None, name: op }, Span::new(start, end))
    },
    <start:@L> <qual:QualifiedOperator> <end:@R> => {
        Spanned::new(QualifiedIdent { module: Some(qual.0), name: qual.1 }, Span::new(start, end))
    },
    <start:@L> ":" <end:@R> => {
        Spanned::new(QualifiedIdent { module: None, name: crate::interner::intern(":") }, Span::new(start, end))
    },
    <start:@L> "~" <end:@R> => {
        Spanned::new(QualifiedIdent { module: None, name: crate::interner::intern("~") }, Span::new(start, end))
    },
};

// Qualified identifier helpers
QualIdent: QualifiedIdent = {
    <name:LowerIdent> => QualifiedIdent { module: None, name },
    <name:UpperIdent> => QualifiedIdent { module: None, name },
    <qual:QualifiedLower> => QualifiedIdent { module: Some(qual.0), name: qual.1 },
    <qual:QualifiedUpper> => QualifiedIdent { module: Some(qual.0), name: qual.1 },
};

QualUpperIdent: QualifiedIdent = {
    <name:UpperIdent> => QualifiedIdent { module: None, name },
    <qual:QualifiedUpper> => QualifiedIdent { module: Some(qual.0), name: qual.1 },
};

// ===== Helpers =====

// Separated list with at least one element
Sep1<T, S>: Vec<T> = {
    <mut v:(<T> S)*> <e:T> => {
        v.push(e);
        v
    }
};

// Separated list (possibly empty)
Sep<T, S>: Vec<T> = {
    <v:Sep1<T, S>?> => v.unwrap_or_default()
};

// ===== Token Mappings =====

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        // Keywords
        "module" => Token::Module,
        "import" => Token::Import,
        "where" => Token::Where,
        "let" => Token::Let,
        "in" => Token::In,
        "do" => Token::Do,
        "case" => Token::Case,
        "of" => Token::Of,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "data" => Token::Data,
        "type" => Token::Type,
        "newtype" => Token::Newtype,
        "class" => Token::Class,
        "instance" => Token::Instance,
        "forall" => Token::Forall,
        "infix" => Token::Infix,
        "infixl" => Token::Infixl,
        "infixr" => Token::Infixr,
        "foreign" => Token::Foreign,
        "derive" => Token::Derive,
        "as" => Token::As,
        "hiding" => Token::Hiding,
        "export" => Token::Export,
        "ado" => Token::Ado,

        // Identifiers
        LowerIdent => Token::LowerIdent(<Ident>),
        UpperIdent => Token::UpperIdent(<Ident>),
        Operator => Token::Operator(<Ident>),

        // Literals
        IntLit => Token::Integer(<i64>),
        FloatLit => Token::Float(<f64>),
        StringLit => Token::String(<String>),
        CharLit => Token::Char(<char>),
        "true" => Token::True,
        "false" => Token::False,

        // Delimiters
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,

        // Special symbols
        "->" => Token::Arrow,
        "=>" => Token::FatArrow,
        "::" => Token::DoubleColon,
        ":" => Token::Colon,
        "|" => Token::Pipe,
        "\\" => Token::Backslash,
        "<-" => Token::LeftArrow,
        "." => Token::Dot,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        "=" => Token::Equals,
        "_" => Token::Underscore,
        "@" => Token::At,
        "`" => Token::Backtick,
        "~" => Token::Tilde,
        HoleLit => Token::Hole(<Ident>),
        QualifiedLower => Token::QualifiedLower(<Ident>, <Ident>),
        QualifiedUpper => Token::QualifiedUpper(<Ident>, <Ident>),
        QualifiedOperator => Token::QualifiedOperator(<Ident>, <Ident>),
        QualifiedDo => Token::QualifiedDo(<Ident>),
        QualifiedAdo => Token::QualifiedAdo(<Ident>),
    }
}
