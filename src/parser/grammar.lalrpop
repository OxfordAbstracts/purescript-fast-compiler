// LALRPOP grammar for PureScript
// Incrementally expanded from MVP

use crate::cst::*;
use crate::lexer::Token;
use crate::ast::span::Span;
use crate::lexer::token::Ident;

grammar;

// ===== Module Structure =====

pub Module: Module = {
    <start:@L> "module" <name:UpperIdent> "where" <decls:(";" <Decl>)*> ";"? <end:@R> => {
        Module {
            span: Span::new(start, end),
            name: Spanned::new(
                ModuleName { parts: vec![name] },
                Span::new(start, end)
            ),
            exports: None,
            imports: vec![],
            decls,
        }
    }
};

// ===== Declarations =====

Decl: Decl = {
    TypeSignature,
    ValueDecl,
};

TypeSignature: Decl = {
    <start:@L> <name:LowerIdentSpanned> "::" <ty:TypeExpr> <end:@R> => {
        Decl::TypeSignature {
            span: Span::new(start, end),
            name,
            ty,
        }
    }
};

ValueDecl: Decl = {
    <start:@L> <name:LowerIdentSpanned> <binders:BinderAtom*> "=" <expr:Expr> <end:@R> => {
        Decl::Value {
            span: Span::new(start, end),
            name,
            binders,
            guarded: GuardedExpr::Unconditional(Box::new(expr)),
        }
    }
};

// ===== Expressions =====
//
// Precedence (low to high):
//   Expr         = Lambda | If | OperatorExpr
//   OperatorExpr = AppExpr (Operator AppExpr)*
//   AppExpr      = AtomExpr+  (left-associative application)
//   AtomExpr     = Literal | Var | Constructor | Parens

pub Expr: Expr = {
    LambdaExpr,
    IfExpr,
    OperatorExpr,
};

LambdaExpr: Expr = {
    <start:@L> "\\" <binders:BinderAtom+> "->" <body:Expr> <end:@R> => {
        Expr::Lambda {
            span: Span::new(start, end),
            binders,
            body: Box::new(body),
        }
    }
};

IfExpr: Expr = {
    <start:@L> "if" <cond:Expr> "then" <then_expr:Expr> "else" <else_expr:Expr> <end:@R> => {
        Expr::If {
            span: Span::new(start, end),
            cond: Box::new(cond),
            then_expr: Box::new(then_expr),
            else_expr: Box::new(else_expr),
        }
    }
};

OperatorExpr: Expr = {
    <start:@L> <left:AppExpr> <op:OperatorSpanned> <right:OperatorExpr> <end:@R> => {
        Expr::Op {
            span: Span::new(start, end),
            left: Box::new(left),
            op,
            right: Box::new(right),
        }
    },
    AppExpr,
};

OperatorSpanned: Spanned<Ident> = {
    <start:@L> <op:Operator> <end:@R> => Spanned::new(op, Span::new(start, end)),
};

AppExpr: Expr = {
    <start:@L> <func:AppExpr> <arg:AtomExpr> <end:@R> => {
        Expr::App {
            span: Span::new(start, end),
            func: Box::new(func),
            arg: Box::new(arg),
        }
    },
    AtomExpr,
};

AtomExpr: Expr = {
    <start:@L> <lit:Literal> <end:@R> => {
        Expr::Literal {
            span: Span::new(start, end),
            lit,
        }
    },
    <start:@L> <name:LowerIdent> <end:@R> => {
        Expr::Var {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name },
        }
    },
    <start:@L> <name:UpperIdent> <end:@R> => {
        Expr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name },
        }
    },
    <start:@L> "(" <expr:Expr> ")" <end:@R> => {
        Expr::Parens {
            span: Span::new(start, end),
            expr: Box::new(expr),
        }
    },
};

// ===== Types =====

pub TypeExpr: TypeExpr = {
    FunctionTypeExpr,
};

FunctionTypeExpr: TypeExpr = {
    <start:@L> <from:AppTypeExpr> "->" <to:FunctionTypeExpr> <end:@R> => {
        TypeExpr::Function {
            span: Span::new(start, end),
            from: Box::new(from),
            to: Box::new(to),
        }
    },
    AppTypeExpr,
};

AppTypeExpr: TypeExpr = {
    <start:@L> <constructor:AppTypeExpr> <arg:AtomicTypeExpr> <end:@R> => {
        TypeExpr::App {
            span: Span::new(start, end),
            constructor: Box::new(constructor),
            arg: Box::new(arg),
        }
    },
    AtomicTypeExpr,
};

AtomicTypeExpr: TypeExpr = {
    <start:@L> <name:LowerIdent> <end:@R> => {
        TypeExpr::Var {
            span: Span::new(start, end),
            name: Spanned::new(name, Span::new(start, end)),
        }
    },
    <start:@L> <name:UpperIdent> <end:@R> => {
        TypeExpr::Constructor {
            span: Span::new(start, end),
            name: QualifiedIdent { module: None, name },
        }
    },
    <start:@L> "(" <ty:TypeExpr> ")" <end:@R> => {
        TypeExpr::Parens {
            span: Span::new(start, end),
            ty: Box::new(ty),
        }
    },
};

// ===== Literals =====

Literal: Literal = {
    <IntLit> => Literal::Int(<>),
    <StringLit> => Literal::String(<>),
    "true" => Literal::Boolean(true),
    "false" => Literal::Boolean(false),
};

// ===== Binders =====

BinderAtom: Binder = {
    <start:@L> <name:LowerIdentSpanned> <end:@R> => {
        Binder::Var {
            span: Span::new(start, end),
            name,
        }
    },
};

// ===== Identifiers =====

LowerIdentSpanned: Spanned<Ident> = {
    <start:@L> <name:LowerIdent> <end:@R> => {
        Spanned::new(name, Span::new(start, end))
    }
};

// ===== Token Mappings =====

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        "module" => Token::Module,
        "where" => Token::Where,
        "true" => Token::True,
        "false" => Token::False,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "\\" => Token::Backslash,
        ";" => Token::LayoutSep,
        LowerIdent => Token::LowerIdent(<Ident>),
        UpperIdent => Token::UpperIdent(<Ident>),
        Operator => Token::Operator(<Ident>),
        IntLit => Token::Integer(<i64>),
        StringLit => Token::String(<String>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "::" => Token::DoubleColon,
        "->" => Token::Arrow,
        "=" => Token::Equals,
    }
}
